### 无重复字符的最长子串

* 思路一
    * 简单粗暴些, 我们可以枚举所有的子串, 然后再判断当前子串是否有重复, 不断更新维护的`maxLength`, 不过这种时间复杂度太大, 再`LeetCode`上不会给通过的, 有兴趣的小伙伴也可以自己写一下试试
  
* 思路二
    1. 我们创建一个`hashMap`, `start`, `maxLength`, 哈希表里面存放的键值对是某个字符最后出现的位置, `start`是每个子串开始的位置, `maxLength`是维护的最子串最长的长度
    2. 对当前字符串进行遍历, 如果这个`hashMap`中已经存在了某个字符, 说明我们遇到了重复的字符, 那么判断一下这个字符在`hashMap`中的值是否大于等于`start`, 如果大于等于, 说明从前一个`start`开始的子串已经不是无重复的子串了, 需要从现在的字符的`之前位置`的下一个来寻求新的子串, 所以将 `start`赋值为`之前该字符的位置+1`
    3. 既然已经开始寻求新的子串, 说明上一个子串已经结束, 现在可以更新一下`maxLength`的值, 即: `当前遍历元素的下标`减去`start`再加1
    4. 最后别忘记更新`hashMap`里的值

    

